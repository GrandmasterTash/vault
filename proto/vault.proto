syntax = "proto3";
import "common.proto";
package grpc.vault;

service Vault {
    // User orientated (never expose to direct clients though!).
    rpc HashPassword (HashRequest) returns (HashResponse) {} // Create or overwrite an existing password.
    rpc ValidatePassword (ValidateRequest) returns (ValidateResponse) {}
    rpc ChangePassword (ChangeRequest) returns (common.Empty) {} // when existing is known but must be rotated or is no-longer valid.
    rpc StartResetPassword (StartResetRequest) returns (StartResetResponse) {} // 2-phase for when existing is forgotten.
    rpc CompleteResetPassword (CompleteResetRequest) returns (common.Empty) {}

    // TODO: Document (once password type is introduced).
    // Maintenance orientated.
    // TODO: Doc that active policy has eventual consistency.
    rpc CreatePasswordPolicy (CreatePolicyRequest) returns (CreatePolicyResponse) {}
    rpc GetActivePolicy (GetActivePolicyRequest) returns (GetActivePolicyResponse) {}
    // TODO: Doc that active policy has eventual consistency.
    rpc MakeActive (MakeActiveRequest) returns (common.Empty) {}
    rpc GetPolicies (common.Empty) returns (GetPoliciesResponse) {}
    rpc ImportPasswords (stream ImportPasswordRequest) returns (stream ImportPasswordResponse) {}
    rpc InvalidatePassword (InvalidateRequest) returns (common.Empty) {} // Mark a password as needing to be changed
    rpc DeletePassword (DeleteRequest) returns (DeleteResponse) {}
    rpc DeletePasswords (stream DeleteRequest) returns (stream DeleteResponse) {}
    // TODO: GetPasswordTypes (configs)
    // TODO: DeletePasswordType - (config)
}

message CreatePolicyRequest {
    NewPolicy policy = 1;
    bool activate = 2;
    optional string password_type = 3; // DEFAULT will be implied if not specified.
}

message Policy {
    string policy_id = 1;            // Generated when created.
    uint32 max_history_length = 2;   // How many passwords to store in history to prevent re-use of old ones.
    uint32 max_age_days = 3;         // Passwords will expire after this period and must be changed.
    uint32 min_length = 4;           // Minimum number of characters allowed.
    uint32 max_length = 5;           // Maximum number of characters allowed.
    uint32 max_character_repeat = 6; // Maximum number of times any given character can be used. For example, If 1, 'loopy' is prohibited but 'lopy' is allowed.
    uint32 min_letters = 7;
    uint32 max_letters = 8;
    uint32 min_numbers = 9;
    uint32 max_numbers = 10;
    uint32 min_symbols = 11;
    uint32 max_symbols = 12;
    uint32 max_failures = 13;
    uint32 lockout_seconds = 14;
    bool mixed_case_required = 15;
    uint32 reset_timeout_seconds = 16;
    oneof algorithm {
        ArgonPolicy argon_policy = 17;
        BCryptPolicy bcrypt_policy = 18;
        PBKDF2Policy pbkdf2_policy = 19;
    }
    repeated string prohibited_phrases = 20;
    uint64 created_on = 21;
}

message NewPolicy {
    uint32 max_history_length = 1;   // How many passwords to store in history to prevent re-use of old ones.
    uint32 max_age_days = 2;         // Passwords will expire after this period and must be changed.
    uint32 min_length = 3;           // Minimum number of characters allowed.
    uint32 max_length = 4;           // Maximum number of characters allowed.
    uint32 max_character_repeat = 5; // Maximum number of times any given character can be used. For example, If 1, 'loopy' is prohibited but 'lopy' is allowed.
    uint32 min_letters = 6;
    uint32 max_letters = 7;
    uint32 min_numbers = 8;
    uint32 max_numbers = 9;
    uint32 min_symbols = 10;
    uint32 max_symbols = 11;
    uint32 max_failures = 12;
    uint32 lockout_seconds = 13;
    bool mixed_case_required = 14;
    uint32 reset_timeout_seconds = 15;
    oneof algorithm {
        ArgonPolicy argon_policy = 16;
        BCryptPolicy bcrypt_policy = 17;
        PBKDF2Policy pbkdf2_policy = 18;
    }
    repeated string prohibited_phrases = 19;
}

// https://en.wikipedia.org/wiki/Argon2
message ArgonPolicy {
    uint32 parallelism = 1;
    uint32 tag_length = 2;
    uint32 memory_size_kb = 3;
    uint32 iterations = 4;
    uint32 version = 5;
    enum HashType {
        ARGON2D = 0;
        ARGON2I = 1;
        ARGON2ID = 2;
    }
    HashType hash_type = 6;
}

// https://en.wikipedia.org/wiki/Bcrypt
message BCryptPolicy {
    enum BCryptVersion {
        TWOA = 0;
        TWOX = 1;
        TWOY = 2;
        TWOB = 3;
    }
    BCryptVersion version = 1;
    uint32 cost = 2;
}

// https://en.wikipedia.org/wiki/PBKDF2
message PBKDF2Policy {
    uint32 cost = 1;
    uint32 output_len = 2;
}

message CreatePolicyResponse {
    string policy_id = 1;
}

message MakeActiveRequest {
    string policy_id = 1;
    optional string password_type = 2; // DEFAULT will be implied if not specified.
}

message GetPoliciesResponse {
    repeated Policy policies = 1;
}

message GetActivePolicyRequest {
    optional string password_type = 1;
}

message GetActivePolicyResponse {
    Policy policy = 1;
    uint64 activated_on = 2;
}

message ImportPasswordRequest {
    oneof password {
        string plain_text_password = 1;
        string phc_string = 2;
    };
    optional string password_type = 3; // DEFAULT will be implied if not specified.
}

message ImportPasswordResponse {
    oneof result {
        string password_id = 1;
        string failure_message = 2;
    }
}

message HashRequest {
    string plain_text_password = 1;
    optional string password_id = 2;
    optional string password_type = 3; // DEFAULT will be implied if not specified.
}

message HashResponse {
    string password_id = 1;
}

message ValidateRequest {
    string password_id = 1;
    string plain_text_password = 2;
}

message ValidateResponse {
    bool must_change = 1; // TODO: Consider dropping this and using an error status.
}

message InvalidateRequest {
    string password_id = 1;
}

message ChangeRequest {
    string plain_text_password = 1;
    string new_plain_text_password = 2;
    optional string password_id = 3;
}

message StartResetRequest {
    string password_id = 1;
}

message StartResetResponse {
    string reset_code = 1;
}

message CompleteResetRequest {
    string password_id = 1;
    string reset_code = 2;
    string plain_text_password = 3;
}

message DeleteRequest {
    string password_id = 1;
}

message DeleteResponse {
    bool deleted = 1;
}